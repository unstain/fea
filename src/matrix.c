/**
 * CREATED: 03/22/16
 * AUTHOR:  Adelin A. Destain
 */

#include "matrix.h"

/**
 * Allocate memory for a two dimensional c array.
 * 
 * Uses the malloc function to allocate memory for a two dimensional
 * c array of double types.
 * 
 * @param rows A non-negative integer representing the number of rows in
 * the 2-D array.
 * 
 * @param columns A non-negative integer representing the number of
 * columns in the 2-D array.
 * 
 * @return Pointer to the 2-D array of the double (64 bit floating point
 * number) type.
 */
double ** generate_matrix(int rows, int columns)
{
	int i;
	double ** result;
	result = (double**)malloc(rows * sizeof(double*));
	for (i = 0; i < rows; i++)
	{
		result[i] = (double*)malloc(columns * sizeof(double));
	}
	
	return result;
}

/**
 * Set the value of all elements in a 2-D array to zero.
 * 
 * @param m Pointer to the 2-D array of doubles (64 bit floating point
 * numbers). The memory should already be allocated for the array.
 * 
 * @param rows A non-negative integer representing the number of rows in
 * the 2-D array.
 * 
 * @param columns A non-negative integer representing the number of
 * columns in the 2-D array.
 */
int zero_matrix(double ** m, int rows, int columns)
{
	int i, j;
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < columns; j++)
			m[i][j] = 0;
	}

	return 0;
}

/**
 * Print a 2-D array to a file.
 * 
 * @param out Pointer to the file to be written to. To print to the
 * terminal, set this value to stdout or stderr.
 * 
 * @param m Pointer to the 2-D array of doubles (64 bit floating point
 * numbers). The memory should already be allocated for the array.
 * 
 * @param num_rows A non-negative integer representing the number of rows in
 * the 2-D array.
 * 
 * @param num_columns A non-negative integer representing the number of
 * columns in the 2-D array.
 */
int print_matrix(FILE * out, double ** m, int num_rows, int num_cols)
{
	int i, j;
	for (i = 0; i < num_rows; i++)
	{
		for (j = 0; j < num_cols; j++)
		{
			if (m[i][j] >= 0.0)
				fprintf(out, " ");
			fprintf(out, "%5.5e\t",m[i][j]);
		}
		fprintf(out, "\n");
	}
	
	return 0;
}

/**
 * Print an array to a file.
 * 
 * @param out Pointer to the file to be written to. To print to the
 * terminal, set this value to stdout or stderr.
 * 
 * @param a Pointer to the 1-D array of doubles (64 bit floating point
 * numbers). The memory should already be allocated.
 * 
 * @param s A non-negative integer representing the size of the array.
 */
int print_array(FILE * out, double * a, int s)
{
	int i;
	
	for (i = 0; i < s; i++)
	{
		if (a[i] >= 0.0)
			fprintf(out, " ");
		fprintf(out, "%5.5e\n", a[i]);
	}
	
	return 0;
}

/**
 * Perform Crout's LU Decomposition on a given 2-D array.
 * 
 * This function is adapted from an AERO 220 MATLAB function. Remember
 * to free all matrices returned by this function using the
 * destroy_matrix function.
 * 
 * @param m Square 2-D array to be decomposed.
 * 
 * @param s Number of rows and columns of the matrix. Size of the matrix.
 * 
 * @return Pointer to a matrix separate from the input matrix. This is
 * the LU decomposition of the input matrix. Memory is allocated inside
 * this function for this variable and must be freed.
 */
double ** ludecomp(double ** m, int s)
{
	double ** l = generate_matrix(s, s);
	int i, j, k;
	double sum;

	/* Initialize the first column of the L matrix to equal the first
	   column of the input matrix. */
	for (i = 0; i < s; i++)
		l[i][0] = m[i][0];
	
	/* Initialize the U matrix. */
	for (i = 1; i < s; i++)
	{
		l[0][i] = m[0][i] / l[0][0];
	}

	for (i = 1; i < s; i++)
	{
		/* Solve the L element. */
		for (j = 1; j <= i; j++)
		{
			sum = 0.0;
			for (k = 0; k < j; k++)
				sum += l[i][k] * l[k][j];
			
			l[i][j] = m[i][j] - sum;
		}

		/* Solve for the U element. */
		for (j = i + 1; j < s; j++)
		{
			sum = 0.0;
			for (k = 0; k < i; k++)
				sum += l[i][k] * l[k][j];

			l[i][j] = (m[i][j] - sum) / l[i][i];
		}
	}

	return l;
}

int ludecomp_fast(double ** l, int s)
{
	int i, j, k;
	double sum;

	/* Initialize the U matrix. */
	for (i = 1; i < s; i++)
	{
		l[0][i] = l[0][i] / l[0][0];
	}

	for (i = 1; i < s; i++)
	{
		/* Solve the L element. */
		for (j = 1; j <= i; j++)
		{
			sum = 0.0;
			for (k = 0; k < j; k++)
				sum += l[i][k] * l[k][j];
			
			l[i][j] = l[i][j] - sum;
		}
		
		/* Solve for the U element. */
		for (j = i + 1; j < s; j++)
		{
			sum = 0.0;
			for (k = 0; k < i; k++)
				sum += l[i][k] * l[k][j];

			l[i][j] = (l[i][j] - sum) / l[i][i];
		}
	}

	return 0;
}

/**
 * Perform forward substitution of a lower triangular matrix.
 * 
 * Remember to free all pointers generated by this function using the
 * free function.
 * 
 * @param m Pointer to a square matrix representing the coefficients of
 * a system of equations.
 * 
 * @param a Pointer to the array of constants.
 * 
 * @param s Non-negative integer representing the number of rows and
 * columns of the matrix, and the length of the array of constants.
 * 
 * @return Pointer to an an array with the solution. Memory for this 
 * array is allocated by the function.
 */
double * fwdsub_matrix(double ** m, double * a, int s)
{
	int i, j;
	double c;
	double * r = (double *)malloc(sizeof(double) * s);
	
	for (i = 0; i < s; i++)
	{
		c = 0;
		for (j = 0; j < i; j++)
			c += r[j] * m[i][j];

		r[i] = (a[i] - c) / m[i][i];
	}
	
	return r;
}

/**
 * Perform back substitution of an LU decomposition.
 * 
 * Because the ludecomp function returns both the L and U matrix
 * combined into one, a modified back substitution method is necessary
 * to solve the upper triangular matrix of the decomposed matrix. Be
 * sure to free all arrays returned by this function.
 * 
 * @param m Pointer to the 2-D matrix that is the result of a call to
 * the ludecomp function. It is also a matrix of coefficients.
 * 
 * @param a Pointer to the array of solutions.
 * 
 * @param s Non-negative integer representing the number of rows and
 * columns of the matrix, and the length of the array of constants.
 * 
 * @return Pointer to an an array with the solution. Memory for this 
 * array is allocated by the function.
 */
double * lubacksub_matrix(double ** m, double * a, int s)
{
	int i, j;
	double c;
	double * r = (double *)malloc(sizeof(double) * s);

	for (i = s; i >= 0; i--)
	{
		c = 0;
		for (j = i + 1; j < s; j++)
			c += r[j] * m[i][j];

		r[i] = a[i] - c;
	}

	return r;
}

/**
 * Perform backward substitution of an upper triangular matrix.
 * 
 * @param m Pointer to the upper triangular matrix of coefficients.
 * 
 * @param a Pointer to the array of solutions.
 * 
 * @param s Non-negative integer representing the number of rows and
 * columns of the matrix, and the length of the array of constants.
 * 
 * @return Pointer to an an array with the solution. Memory for this 
 * array is allocated by the function.
 */
double * backsub_matrix(double ** m, double * a, int s)
{
	int i, j;
	double c;
	double * r = (double *)malloc(sizeof(double) * s);
	
	for (i = s; i >= 0; i--)
	{
		c = 0;
		for (j = i; j < s; j++)
			c += r[j] * m[i][j];
		
		r[i] = (a[i] - c) / m[i][i];
	}
	
	return r;
}

/**
 * Solve a system of equations.
 * 
 * [A][x] = [b]. This function solves for [x] using Crout's LU
 * decomposition method. Remember to free the returned array.
 * 
 * @param m Pointer to the matrix of coefficients.
 * 
 * @param a Pointer to the array of constants.
 * 
 * @param s Non-negative integer representing the number of rows and
 * columns of the matrix, and the length of the array of constants.
 * 
 * @return Pointer t
 */
double * solve_matrix(double ** m, double * a, int s)
{
	double ** lu = ludecomp(m, s);

	double * y = fwdsub_matrix(lu, a, s);

	double * r = lubacksub_matrix(lu, y, s);
	
	destroy_matrix(lu, s);
	free((void*)y);
	
	return r;
}

double ** invert_matrix(double ** m, int s)
{
	double ** lu = ludecomp(m, s);
	
	/*
	int i;
	for (i = 0; i < s; i++)
	{
		i - 1;
	}
	
	return lu;
	*/
	return lu;
}

/**
 * Free memory allocated for a matrix.
 * 
 * @param matrix Pointer to the 2-D array of doubles to be freed.
 * 
 * @param rows Number of rows in the matrix.
 */
int destroy_matrix(double ** matrix, int rows)
{
	int i;
	for (i = 0; i < rows; i++)
	{
		free((void*)matrix[i]);
	}
	free((void*)matrix);

	return 0;
}
